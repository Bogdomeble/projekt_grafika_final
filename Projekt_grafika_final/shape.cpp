    #define GLM_ENABLE_EXPERIMENTAL

    #include "Shape.h"
    #include <iostream> // For error messages
    #include <glm/gtc/type_ptr.hpp> // For glm::value_ptr
    #include <glm/gtx/string_cast.hpp> // For glm::to_string (optional, for debugging)
    #include "texture.h" // Assuming you have a Texture class defined

    Shape::Shape() : modelMatrix(1.0f) {
        Type = ShapeType::SHAPE_TYPE_CUSTOM; // Default shape type, can be set later
        // VAO is default constructed. VBO/EBO are pointers, initialized in setupMesh.
    }

    Shape::~Shape() {
        cleanup(); // Ensure OpenGL resources are released
    }

    void Shape::addVertex(const glm::vec3& pos, const glm::vec3& col, const glm::vec2& tex, const glm::vec3& norm) {
        vertices_data.push_back(pos.x);
        vertices_data.push_back(pos.y);
        vertices_data.push_back(pos.z);
        vertices_data.push_back(col.x);
        vertices_data.push_back(col.y);
        vertices_data.push_back(col.z);
        vertices_data.push_back(tex.x);
        vertices_data.push_back(tex.y);
        vertices_data.push_back(norm.x);
        vertices_data.push_back(norm.y);
        vertices_data.push_back(norm.z);
    }

    void Shape::setupMesh() {
        if (meshInitialized) { // Optional: prevent re-initialization or handle it
            cleanup(); // Clean up existing GL resources before re-creating
        }

        // Ensure geometry data is generated by the derived class
        if (vertices_data.empty() || indices_data.empty()) {
            generateGeometry(); // This calls the derived class's implementation
        }

        if (vertices_data.empty() || indices_data.empty()) {
            std::cerr << "Error: Vertex or index data is empty after generation. Cannot setup mesh for Shape." << std::endl;
            return;
        }

        vao.Bind();

        // Create VBO and EBO using the data populated by generateGeometry()
        vbo_ptr = std::make_unique<VBO>(vertices_data.data(), getVerticesSizeInBytes());
        ebo_ptr = std::make_unique<EBO>(indices_data.data(), getIndicesSizeInBytes());

        // Link vertex attributes to the VAO
        // Layout 0: Position
        vao.LinkAttrib(*vbo_ptr, 0, 3, GL_FLOAT, (GLsizei)stride, (void*)0);
        // Layout 1: Color
        vao.LinkAttrib(*vbo_ptr, 1, 3, GL_FLOAT, (GLsizei)stride, (void*)(3 * sizeof(float)));
        // Layout 2: Texture Coordinate
        vao.LinkAttrib(*vbo_ptr, 2, 2, GL_FLOAT, (GLsizei)stride, (void*)(6 * sizeof(float)));
        // Layout 3: Normal
        vao.LinkAttrib(*vbo_ptr, 3, 3, GL_FLOAT, (GLsizei)stride, (void*)(8 * sizeof(float)));

        vao.Unbind();

        meshInitialized = true;
    }

    void Shape::setTexture(Texture* tex) {
        this->shapeTexture = tex;
    }

    void Shape::draw(Shader& shader) {
        if (!meshInitialized) {
            std::cerr << "Error: Mesh not initialized. Cannot draw shape." << std::endl;
            return;
        }

        shader.Activate();

        // Set the model matrix uniform in the shader
        glUniformMatrix4fv(glGetUniformLocation(shader.ID, "model"), 1, GL_FALSE, glm::value_ptr(this->modelMatrix));

        // Bind the shape's specific texture
        if (this->shapeTexture) {
            glActiveTexture(GL_TEXTURE0); // Activate the texture unit the shader expects
            this->shapeTexture->Bind();   // Bind this shape's specific texture
        }

        vao.Bind();
        glDrawElements(GL_TRIANGLES, getIndexCount(), GL_UNSIGNED_INT, 0);
        vao.Unbind();

        // Optional: Unbind texture if you want to be very explicit
        if (this->shapeTexture) {
            glActiveTexture(GL_TEXTURE0);
            this->shapeTexture->Unbind();
        }
    }

    void Shape::cleanup() {
        if (meshInitialized) {
            // Explicitly delete VBO and EBO GL resources via their Delete methods
            // The unique_ptr will then handle deleting the C++ objects.
            if (vbo_ptr) vbo_ptr->Delete();
            if (ebo_ptr) ebo_ptr->Delete();
            vao.Delete(); // VAO also has a Delete method

            vbo_ptr.reset(); // Release ownership
            ebo_ptr.reset(); // Release ownership
            meshInitialized = false;
        }
    }