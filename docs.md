# Project Documentation: OpenGL 3D Scene Renderer

## Table of Contents
1.  [Overview](#overview)
2.  [Core Concepts](#core-concepts)
    *   [OpenGL Rendering Pipeline](#opengl-rendering-pipeline)
    *   [Shaders (GLSL)](#shaders-glsl)
    *   [Transformations](#transformations)
    *   [Lighting](#lighting)
    *   [Texturing](#texturing)
3.  [Project Structure](#project-structure)
4.  [Class Reference](#class-reference)
    *   [`main.cpp`](#maincpp)
    *   [`Shader`](#shader-class)
    *   [`Texture`](#texture-class)
    *   [`Camera`](#camera-class)
    *   [`VAO` (Vertex Array Object)](#vao-class)
    *   [`VBO` (Vertex Buffer Object)](#vbo-class)
    *   [`EBO` (Element Buffer Object)](#ebo-class)
    *   [`Shape` (Abstract Base Class)](#shape-class)
    *   [`Cube` (Derived Shape)](#cube-class)
    *   [`Plane` (Derived Shape)](#plane-class)
    *   [`Pyramid` (Derived Shape)](#pyramid-class)
    *   [`Sphere` (Derived Shape)](#sphere-class)
    *   [`Cylinder` (Derived Shape)](#cylinder-class)
5.  [Shader Files](#shader-files)
    *   [`default.vert`](#defaultvert)
    *   [`default.frag`](#defaultfrag)
    *   [`light.vert`](#lightvert)
    *   [`light.frag`](#lightfrag)
6.  [Build and Run](#build-and-run)
7.  [Future Improvements](#future-improvements)

---

## 1. Overview

This project is a C++ application that uses OpenGL to render a 3D scene, specifically a simple art gallery. It demonstrates core computer graphics concepts including 3D object representation, transformations, lighting, texturing, and camera control. The codebase is structured 코로나ject-oriented principles, with classes मौसम (representing) geometric shapes, shaders, textures, and a camera.

The primary goal is to create a flexible system where new shapes can be easily added and a scene can be constructed by instantiating and positioning these shapes, applying textures, and setting up light sources.

---

## 2. Core Concepts

### OpenGL Rendering Pipeline
OpenGL is a state machine. We provide it with data (vertices, textures) and instructions (shaders, draw calls), and it processes this through a series of stages (the rendering pipeline) to produce a 2D image on the screen. Key stages include Vertex Shading, Primitive Assembly, Geometry Shading (optional), Rasterization, Fragment Shading, and Tests & Blending.

### Shaders (GLSL)
Shaders are small programs written in GLSL (OpenGL Shading Language) that run on the GPU. They give us direct control over programmable stages of the rendering pipeline.
*   **Vertex Shader:** Processes each vertex individually. Responsible for transforming vertex positions from model space to clip space, and passing data (like texture coordinates, normals) to the fragment shader.
*   **Fragment Shader (Pixel Shader):** Processes each "fragment" (potential pixel) generated by rasterization. Responsible for determining the final color of the pixel, often by performing lighting calculations and texture sampling.

### Transformations
3D objects are defined in their own local "model space". To place them in a "world space", then view them from a "camera space", and finally project them onto a 2D "clip space" (and then "screen space"), we use transformation matrices:
*   **Model Matrix:** Transforms vertices from model space to world space (handles translation, rotation, scaling of an object).
*   **View Matrix:** Transforms vertices from world space to camera/view space (simulates camera position and orientation).
*   **Projection Matrix:** Transforms vertices from camera space to clip space (defines the viewing frustum, e.g., perspective or orthographic projection).
    These are often combined: `gl_Position = Projection * View * Model * vec4(vertexPosition, 1.0);`

### Lighting
Simulates how light interacts with surfaces. Common models include:
*   **Ambient Light:** Global, directionless light that illuminates all objects equally, preventing them from being completely black in shadows.
*   **Diffuse Light:** Light that scatters Ereignis (equally) in all directions when it hits a surface. The amount of diffuse light depends on the angle between the surface normal and the light direction.
*   **Specular Light:** Simulates shiny highlights on surfaces. Depends on the light direction, surface normal, and view direction.
*   **Point Light:** A light source that emits light equally in all directions from a single point, with intensity decreasing with distance (attenuation).

### Texturing
Applying 2D images (textures) to the surfaces of 3D objects to add detail and realism. This involves:
*   **Texture Coordinates (UVs):** 2D coordinates (typically ranging from 0 to 1) assigned to each vertex, specifying which part of the texture image maps to that vertex.
*   **Samplers:** Special uniform types in shaders (`sampler2D`) used to access texture data.
*   **Texture Units:** OpenGL provides multiple "slots" (texture units) where textures can be bound. Shaders are told which unit a sampler should use.

---

## 3. Project Structure

The project is typically organized as follows:

*   **Header Files (`.h`):** Contain class declarations and function prototypes.
    *   `camera.h`, `EBO.h`, `shaderClass.h`, `Shape.h`, `texture.h`, `VAO.h`, `VBO.h`
    *   Specific shape headers: `Cube.h`, `Plane.h`, `Pyramid.h`, `Sphere.h`, `Cylinder.h`
    *   Potentially an `include.h` to group common includes.
*   **Source Files (`.cpp`):** Contain class method implementations and the `main` function.
    *   `main.cpp`
    *   `camera.cpp`, `EBO.cpp`, `shaderClass.cpp`, `Shape.cpp`, `texture.cpp`, `VAO.cpp`, `VBO.cpp`
    *   Specific shape sources: `Cube.cpp`, `Plane.cpp`, `Pyramid.cpp`, `Sphere.cpp`, `Cylinder.cpp`
*   **Shader Files (`.vert`, `.frag`):** GLSL code for vertex and fragment shaders.
    *   `default.vert`, `default.frag` (for general objects)
    *   `light.vert`, `light.frag` (for visualizing light sources)
*   **Texture Image Files (`.png`, `.jpg`, etc.):** Image files used for texturing.
*   **External Libraries:**
    *   **GLFW:** For window creation and input handling.
    *   **GLAD:** OpenGL Loading Library, to access modern OpenGL functions.
    *   **GLM:** OpenGL Mathematics library, for vector and matrix operations.
    *   **stb_image.h:** Single-file library for loading images.

---

## 4. Class Reference

### `main.cpp`
*   **Purpose:** The main entry point of the application.
*   **Responsibilities:**
    1.  **Initialization:** Initializes GLFW, creates a window, and initializes GLAD.
    2.  **Global OpenGL State:** Sets up global states like depth testing and face culling.
    3.  **Resource Loading:**
        *   Creates and compiles `Shader` objects from shader source files.
        *   Loads `Texture` objects from image files.
    4.  **Scene Setup:**
        *   Creates a `Camera` object.
        *   Instantiates various `Shape`-derived objects (e.g., `Plane` for floor/walls, `Cube`, `Pyramid` for artworks/pedestals, `Sphere`, `Cylinder`).
        *   Sets their model matrices for position, rotation, and scale.
        *   Assigns textures to these shapes using `shape->setTexture()`.
        *   Calls `shape->setupMesh()` for each shape to generate its geometry and OpenGL buffers.
        *   Creates light source visualization objects (typically small cubes).
    5.  **Render Loop (`while (!glfwWindowShouldClose(window))`):**
        *   Handles per-frame logic: timing, input processing.
        *   Updates camera position/orientation based on input.
        *   Updates light positions or other animated elements.
        *   Clears the screen (color, depth, and stencil buffers).
        *   Sets shader uniforms that are common for a pass (e.g., camera matrix, light properties).
        *   Iterates through scene objects and calls their `draw()` method.
        *   Swaps front and back buffers (`glfwSwapBuffers`).
        *   Polls for events (`glfwPollEvents`).
    6.  **Cleanup:** Deletes textures, shaders, and other allocated resources. Terminates GLFW.

### `Shader` Class
*   **Header:** `shaderClass.h`
*   **Source:** `shaderClass.cpp`
*   **Purpose:** Encapsulates an OpenGL shader program, which consists of a vertex shader and a fragment shader (and optionally others like geometry shader).
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the linked shader program.
*   **Key Methods:**
    *   `Shader(const char* vertexFile, const char* fragmentFile)`: Constructor. Reads shader source code from specified files, compiles the vertex and fragment shaders, links them into a shader program, and stores the program `ID`. Handles error checking during compilation and linking.
    *   `Activate()`: Calls `glUseProgram(ID)` to make this shader program active for subsequent rendering calls.
    *   `Delete()`: Calls `glDeleteProgram(ID)` to free the GPU resources associated with the shader program.
    *   (Helper function `get_file_contents` is typically used internally to read shader files.)

### `Texture` Class
*   **Header:** `texture.h`
*   **Source:** `texture.cpp`
*   **Purpose:** Manages an OpenGL texture object.
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the texture object.
    *   `type`: `GLenum` specifying the texture type (e.g., `GL_TEXTURE_2D`).
*   **Key Methods:**
    *   `Texture(const char* image_path, GLenum tex_type, GLenum active_slot, GLenum format_hint, GLenum pixel_type_hint)`: Constructor.
        1.  Loads an image file from `image_path` using `stb_image.h`.
        2.  Checks for loading errors. If an error occurs, `ID` is typically set to `0`.
        3.  Determines the data format (`GL_RGB`, `GL_RGBA`, etc.) based on the number of channels in the loaded image.
        4.  Generates an OpenGL texture ID using `glGenTextures`.
        5.  Activates the specified `active_slot` (texture unit) using `glActiveTexture`.
        6.  Binds the new texture object using `glBindTexture`.
        7.  Sets pixel storage parameters (especially `glPixelStorei(GL_UNPACK_ALIGNMENT, 1)` for tightly packed data from `stb_image`).
        8.  Sets texture parameters (filtering: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`; wrapping: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`).
        9.  Uploads the image data to the GPU using `glTexImage2D`. It uses an appropriate `internalFormat` (like `GL_RGBA8`) and the `data_format_from_channels`.
        10. Generates mipmaps using `glGenerateMipmap`.
        11. Frees the CPU-side image data loaded by `stb_image` using `stbi_image_free`.
    *   `texUnit(Shader& shader, const char* uniform_name, GLuint unit_index)`: Tells a specified shader's sampler uniform (`uniform_name`) to use the texture bound to the texture unit `unit_index`. It activates the shader and calls `glUniform1i`.
    *   `Bind()`: Calls `glBindTexture(type, ID)` to bind this texture. Assumes `glActiveTexture` was called beforehand if a specific unit is intended.
    *   `Unbind()`: Calls `glBindTexture(type, 0)` to unbind the texture of this type from the currently active texture unit.
    *   `Delete()`: Calls `glDeleteTextures(1, &ID)` to free the GPU resources and sets `ID` to 0.

### `Camera` Class
*   **Header:** `camera.h`
*   **Source:** `camera.cpp`
*   **Purpose:** Manages the view and projection transformations, simulating a camera in the 3D scene. Handles user input for camera movement and orientation.
*   **Key Members:**
    *   `Position`: `glm::vec3` for the camera's world space position.
    *   `Orientation`: `glm::vec3` a unit vector indicating the direction the camera is looking (forward vector).
    *   `Up`: `glm::vec3` a unit vector indicating the up direction for the camera (world up, typically `(0,1,0)`).
    *   `cameraMatrix`: `glm::mat4` that stores the combined View * Projection matrix.
    *   `width`, `height`: Dimensions of the viewport, used for aspect ratio in projection.
    *   `speed`, `sensitivity`: Control camera movement speed and mouse look sensitivity.
    *   `firstClick`: `bool` to handle initial mouse capture smoothly.
    *   `deltaTime`: Time difference between frames, used for frame-rate independent movement.
*   **Key Methods:**
    *   `Camera(int width, int height, glm::vec3 position)`: Constructor, initializes camera properties.
    *   `updateMatrix(float FOVdeg, float nearPlane, float farPlane)`: Calculates the view matrix using `glm::lookAt(Position, Position + Orientation, Up)` and the perspective projection matrix using `glm::perspective()`. Combines them into `cameraMatrix = projection * view`.
    *   `Matrix(Shader& shader, const char* uniform)`: Activates the given `shader` and sends the `cameraMatrix` (View-Projection matrix) to the shader uniform specified by `uniform`.
    *   `Inputs(GLFWwindow* window)`: Handles keyboard input (W,A,S,D, Space, Ctrl) for camera movement (FPS-style) and mouse input for camera orientation (looking around). Implements mouse capture and cursor hiding when the left mouse button is pressed.

### `VAO` (Vertex Array Object) Class
*   **Header:** `VAO.h`
*   **Source:** `VAO.cpp` (if methods are not inline)
*   **Purpose:** Stores all the state needed to supply vertex data. It encapsulates vertex attribute configurations and bindings to VBOs and an EBO. Using a VAO allows you to set up vertex attribute pointers once and then just bind the VAO to draw an object.
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the Vertex Array Object.
*   **Key Methods:**
    *   `VAO()`: Constructor, calls `glGenVertexArrays(1, &ID)` to generate a VAO ID.
    *   `LinkAttrib(VBO& vbo, GLuint layout, GLuint numComponents, GLenum type, GLsizei stride, void* offset)`:
        1.  Binds the associated `vbo`.
        2.  Calls `glVertexAttribPointer` to specify how OpenGL should interpret the vertex data in the VBO for a given attribute `layout` (e.g., position, color, texcoord).
            *   `layout`: The `location` of the vertex attribute in the vertex shader.
            *   `numComponents`: Number of components per attribute (e.g., 3 for `vec3`).
            *   `type`: Data type of components (e.g., `GL_FLOAT`).
            *   `stride`: Byte offset between consecutive vertex attributes.
            *   `offset`: Byte offset of the first component of the first attribute.
        3.  Calls `glEnableVertexAttribArray(layout)` to enable this vertex attribute.
        4.  Unbinds the `vbo` (optional, good practice).
    *   `Bind()`: Calls `glBindVertexArray(ID)`.
    *   `Unbind()`: Calls `glBindVertexArray(0)`.
    *   `Delete()`: Calls `glDeleteVertexArrays(1, &ID)`.

### `VBO` (Vertex Buffer Object) Class
*   **Header:** `VBO.h`
*   **Source:** `VBO.cpp` (if methods are not inline)
*   **Purpose:** Manages an OpenGL buffer object used to store vertex attribute data (like positions, colors, texture coordinates, normals) on the GPU.
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the Vertex Buffer Object.
*   **Key Methods:**
    *   `VBO(GLfloat* vertices, GLsizeiptr size)`: Constructor.
        1.  Calls `glGenBuffers(1, &ID)` to generate a VBO ID.
        2.  Calls `glBindBuffer(GL_ARRAY_BUFFER, ID)` to bind the VBO.
        3.  Calls `glBufferData(GL_ARRAY_BUFFER, size, vertices, GL_STATIC_DRAW)` to allocate memory on the GPU and upload the vertex data. `GL_STATIC_DRAW` indicates the data will be set once and used many times.
    *   `Bind()`: Calls `glBindBuffer(GL_ARRAY_BUFFER, ID)`.
    *   `Unbind()`: Calls `glBindBuffer(GL_ARRAY_BUFFER, 0)`.
    *   `Delete()`: Calls `glDeleteBuffers(1, &ID)`.

### `EBO` (Element Buffer Object) Class
*   **Header:** `EBO.h`
*   **Source:** `EBO.cpp` (if methods are not inline)
*   **Purpose:** Manages an OpenGL buffer object used to store vertex indices. This allows for "indexed drawing" (`glDrawElements`), where you can reuse vertices instead of duplicating them, saving memory and potentially improving performance.
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the Element Buffer Object.
*   **Key Methods:**
    *   `EBO(GLuint* indices, GLsizeiptr size)`: Constructor.
        1.  Calls `glGenBuffers(1, &ID)` to generate an EBO ID.
        2.  Calls `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ID)` to bind the EBO.
        3.  Calls `glBufferData(GL_ELEMENT_ARRAY_BUFFER, size, indices, GL_STATIC_DRAW)` to upload the index data.
    *   `Bind()`: Calls `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ID)`.
    *   `Unbind()`: Calls `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)`.
    *   `Delete()`: Calls `glDeleteBuffers(1, &ID)`.

### `Shape` (Abstract Base Class)
*   **Header:** `Shape.h`
*   **Source:** `Shape.cpp`
*   **Purpose:** Serves as an abstract base class for all renderable geometric shapes in the scene. It handles common functionality like managing VAO/VBO/EBO, model matrix transformations, texture assignment, and providing a common drawing interface.
*   **Key Members (Protected):**
    *   `vertices_data`: `std::vector<GLfloat>` to store the interleaved vertex attribute data (position, color, texture coordinates, normal).
    *   `indices_data`: `std::vector<GLuint>` to store the indices for indexed drawing.
    *   `vao`: A `VAO` object owned by the shape.
    *   `vbo_ptr`, `ebo_ptr`: `std::unique_ptr` to `VBO` and `EBO` objects, managing their lifetime.
    *   `meshInitialized`: `bool` flag indicating if the OpenGL buffers (VAO/VBO/EBO) have been set up.
    *   `shapeTexture`: `Texture*` pointer to the texture assigned to this shape.
*   **Key Members (Public):**
    *   `modelMatrix`: `glm::mat4` representing the object's transformation (translation, rotation, scale) in world space. Initialized to identity.
    *   `stride`: `size_t` defining the byte offset between consecutive full vertex attribute sets.
*   **Key Methods:**
    *   `Shape()`: Constructor, initializes `modelMatrix` and default member values.
    *   `virtual ~Shape()`: Virtual destructor, calls `cleanup()` to ensure OpenGL resources are released when a derived shape object is deleted, especially through a base class pointer.
    *   `addVertex(...)`: Protected helper method for derived classes to easily add a full set of vertex attributes to `vertices_data`.
    *   `virtual void generateGeometry() = 0`: Pure virtual method. Derived classes **must** implement this to populate `vertices_data` and `indices_data` with their specific geometry.
    *   `virtual void setupMesh()`:
        1.  If the mesh is not already initialized (`vertices_data` or `indices_data` are empty), it calls the derived class's `generateGeometry()` method.
        2.  Creates the `VBO` and `EBO` using the data from `vertices_data` and `indices_data`.
        3.  Binds the `VAO`.
        4.  Calls `vao.LinkAttrib()` multiple times to configure how the vertex attributes (position, color, texture coordinates, normal) are laid out in the VBO.
        5.  Unbinds the `VAO`.
        6.  Sets `meshInitialized` to `true`.
    *   `setTexture(Texture* tex)`: Assigns a `Texture` object to this shape's `shapeTexture` member.
    *   `virtual void draw(Shader& shader)`:
        1.  Checks if `meshInitialized`. If not, (optionally attempts `setupMesh()` or) prints an error.
        2.  Activates the provided `shader`.
        3.  Sends the shape's `modelMatrix` to the shader's "model" uniform.
        4.  If `this->shapeTexture` is valid (not null and its `ID` is not 0):
            *   Activates `GL_TEXTURE0` (or the appropriate texture unit).
            *   Binds `this->shapeTexture` using `this->shapeTexture->Bind()`.
        5.  Binds the shape's `VAO`.
        6.  Calls `glDrawElements(GL_TRIANGLES, getIndexCount(), GL_UNSIGNED_INT, 0)` to draw the object using its EBO.
        7.  Unbinds the `VAO`.
    *   `cleanup()`: Deletes the VBO, EBO, and VAO OpenGL resources using their respective `Delete()` methods. Resets smart pointers and `meshInitialized` flag.

### `Cube` (Derived Shape)
*   **Header:** `Cube.h`
*   **Source:** `Cube.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a 3D cube.
*   **Key Members (Private):**
    *   `width`, `height`, `depth`: Dimensions of the cube.
    *   `faceColor`: A `glm::vec3` for the base color of the cube's faces (used when generating vertex data).
*   **Key Methods:**
    *   `Cube(float w, float h, float d, const glm::vec3& color)`: Constructor, initializes dimensions and color.
    *   `void generateGeometry() override`: Implements the geometry generation for a cube.
        *   Defines 8 unique vertex positions for the corners of the cube.
        *   Since each face needs its own normals (and potentially distinct texture coordinates per face for standard UV unwrapping), it defines 24 vertices (4 vertices per face * 6 faces).
        *   For each face:
            *   Adds 4 vertices to `vertices_data` with appropriate positions, the `faceColor`, standard texture coordinates (e.g., (0,0), (1,0), (1,1), (0,1)), and the correct face normal.
            *   Adds 6 indices (for 2 triangles) to `indices_data` to form the face.

### `Plane` (Derived Shape)
*   **Header:** `Plane.h`
*   **Source:** `Plane.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a flat 2D plane in 3D space, typically used for floors, walls, or simple quads like paintings.
*   **Key Members (Private):**
    *   `p_width`, `p_length`: Dimensions of the plane.
    *   `p_color`: Base color.
    *   `p_texScale`: `glm::vec2` to scale texture coordinates (e.g., for tiling).
    *   `p_yOffset`: Y-coordinate offset for the plane (defaults to 0, creating a plane in the XZ plane).
*   **Key Methods:**
    *   `Plane(float width, float length, const glm::vec3& color, const glm::vec2& texScale, float yOffset)`: Constructor.
    *   `void generateGeometry() override`:
        *   Calculates 4 vertex positions for the corners of the plane based on `p_width`, `p_length`, and `p_yOffset`.
        *   Defines a single normal vector (typically `(0,1,0)` if the plane is horizontal and facing up).
        *   Calculates texture coordinates, applying `p_texScale`.
        *   Adds 4 vertices to `vertices_data`.
        *   Adds 6 indices (for 2 triangles) to `indices_data` to form the plane.

### `Pyramid` (Derived Shape)
*   **Header:** `Pyramid.h`
*   **Source:** `Pyramid.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a 4-sided pyramid with a square base.
*   **Key Members (Private):**
    *   `baseColor`, `peakColor`: Colors used for the base and the peak vertex/sides when generating geometry.
*   **Key Methods:**
    *   `Pyramid(const glm::vec3& bColor, const glm::vec3& pColor)`: Constructor.
    *   `void generateGeometry() override`:
        *   Defines vertices for the square base (4 vertices).
        *   Defines a peak vertex.
        *   Similar to the cube, if different faces need different normals (which they do for a pyramid), vertices are duplicated.
        *   Adds vertices for the bottom face (typically 2 triangles, 4 vertices with bottom-facing normal).
        *   Adds vertices for each of the 4 triangular side faces (3 vertices per side, each with its specific normal).
        *   Populates `indices_data` accordingly.

### `Sphere` (Derived Shape)
*   **Header:** `Sphere.h`
*   **Source:** `Sphere.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a sphere.
*   **Key Members (Private):**
    *   `radius`: Radius of the sphere.
    *   `sectorCount`: Number of longitudinal segments (like orange slices).
    *   `stackCount`: Number of latitudinal segments (like horizontal rings).
    *   `sphereColor`: Base color.
*   **Key Methods:**
    *   `Sphere(float r, unsigned int sectors, unsigned int stacks, const glm::vec3& color)`: Constructor.
    *   `void generateGeometry() override`:
        *   Generates vertices by iterating through stack and sector angles using spherical coordinates.
        *   For each vertex, calculates:
            *   Position `(x,y,z)`.
            *   Normal (for a sphere centered at origin, normal is `normalize(position)`).
            *   Texture coordinates (typically mapping longitude to `u` and latitude to `v`).
        *   Adds vertices to `vertices_data`.
        *   Generates indices to form triangular strips connecting the stacks and sectors. Handles poles carefully.

### `Cylinder` (Derived Shape)
*   **Header:** `Cylinder.h`
*   **Source:** `Cylinder.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a cylinder (or a cone/frustum if top and base radii differ).
*   **Key Members (Private):**
    *   `baseRadius`, `topRadius`: Radii of the bottom and top circular caps.
    *   `height`: Height of the cylinder.
    *   `sectorCount`: Number of segments around the circular caps.
    *   `stackCount`: Number of segments along the height for the side walls.
    *   `smoothShading`: Boolean to indicate if side wall normals should be smooth (averaged) or flat (per-face, requiring more vertices usually).
    *   `cylinderColor`: Base color.
*   **Key Methods:**
    *   `Cylinder(float br, float tr, float h, unsigned int sectors, unsigned int stacks, bool smooth, const glm::vec3& color)`: Constructor.
    *   `void generateGeometry() override`:
        1.  **Side Walls:**
            *   Iterates through `stackCount` and `sectorCount`.
            *   For each point on the side, calculates vertex position by interpolating radius from `baseRadius` to `topRadius` along the height.
            *   Calculates normals: For smooth shading on a cylinder, normal points radially outward from the Y-axis. For a cone, it's more complex.
            *   Calculates texture coordinates (typically `u` maps around the circumference, `v` maps along the height).
            *   Adds vertices to `vertices_data`.
            *   Generates indices for the triangular strips forming the side walls.
        2.  **Caps (Top and Bottom):**
            *   If `baseRadius > 0`, generates a bottom circular cap (a triangle fan originating from a center vertex). Vertices have normals pointing downwards (`(0,-1,0)`).
            *   If `topRadius > 0`, generates a top circular cap (triangle fan). Vertices have normals pointing upwards (`(0,1,0)`).
            *   Calculates planar texture coordinates for the caps.
            *   Adds vertices and indices for the caps.
    *   *Winding order for cylinder faces is critical for correct culling and may require careful debugging.*

---

## 5. Shader Files

### `default.vert` (Object Vertex Shader)
*   **Inputs (`in`):**
    *   `layout (location = 0) in vec3 aPos;` : Per-vertex position (in model space).
    *   `layout (location = 1) in vec3 aColor;`: Per-vertex color.
    *   `layout (location = 2) in vec2 aTex;`  : Per-vertex texture coordinates.
    *   `layout (location = 3) in vec3 aNormal;`: Per-vertex normal (in model space).
*   **Outputs (`out`):**
    *   `out vec3 crntPos;`: Fragment's position in world space (interpolated).
    *   `out vec3 Normal;`  : Fragment's normal (interpolated, **should be transformed to world space**).
    *   `out vec2 texCoord;`: Texture coordinates (interpolated).
    *   `out vec3 color;`   : Vertex color (interpolated).
*   **Uniforms (`uniform`):**
    *   `uniform mat4 model;`    : Model matrix for the current object.
    *   `uniform mat4 camMatrix;`: Combined View * Projection matrix.
*   **Functionality:**
    1.  Transforms `aPos` to world space using `model` matrix, outputting to `crntPos`.
    2.  Transforms `crntPos` to clip space using `camMatrix`, setting `gl_Position`.
    3.  Passes `aTex` to `texCoord`.
    4.  Passes `aColor` to `color`.
    5.  **Crucially, for correct lighting, `aNormal` should be transformed to world space using the normal matrix (`mat3(transpose(inverse(model)))`) before being output to `Normal`. The provided user shader simplifies this to `Normal = aNormal;` which is only correct if the model matrix contains no rotations or non-uniform scales.**

### `default.frag` (Object Fragment Shader)
*   **Inputs (`in`):** (Received from vertex shader, interpolated)
    *   `in vec3 crntPos;` : Fragment position in world space.
    *   `in vec3 Normal;`   : Fragment normal in world space.
    *   `in vec2 texCoord;` : Texture coordinates.
    *   `in vec3 color;`    : Interpolated vertex color (currently unused in the lighting calculation shown).
*   **Uniforms (`uniform`):**
    *   `uniform sampler2D tex0;`: Sampler for the object's diffuse texture.
    *   `uniform vec4 lightColor;`: Color of the single point light source.
    *   `uniform vec3 lightPos;`  : Position of the single point light source in world space.
    *   `uniform vec3 camPos;`    : Position of the camera in world space.
*   **Functionality (Single Point Light - Blinn-Phong like):**
    1.  **Ambient:** Calculates a small ambient light component.
    2.  **Diffuse:**
        *   Normalizes the incoming `Normal`.
        *   Calculates `lightDirection` from fragment to light.
        *   Calculates diffuse intensity using `max(dot(normal, lightDirection), 0.0)`.
    3.  **Specular:**
        *   Calculates `viewDirection` from fragment to camera.
        *   Calculates `reflectionDirection` of light off the surface.
        *   Calculates specular power using `pow(max(dot(viewDirection, reflectionDirection), 0.0), shininessFactor)`. (User shader has `shininessFactor = 8`).
    4.  **Final Color:** Combines ambient, diffuse, and specular components, then modulates this by the `lightColor` and the color sampled from `tex0` using `texCoord`. `FragColor` is the output.

### `light.vert` (Light Source Vertex Shader)
*   **Inputs (`in`):**
    *   `layout (location = 0) in vec3 aPos;`: Vertex position of the light object (e.g., a cube).
*   **Uniforms (`uniform`):**
    *   `uniform mat4 model;`    : Model matrix for the light object (its position/scale).
    *   `uniform mat4 camMatrix;`: Combined View * Projection matrix.
*   **Functionality:** Transforms the light object's vertices to clip space: `gl_Position = camMatrix * model * vec4(aPos, 1.0);`.

### `light.frag` (Light Source Fragment Shader)
*   **Uniforms (`uniform`):**
    *   `uniform vec4 lightColor;`: The color the light source object should appear as.
*   **Functionality:** Sets the output fragment color `FragColor` directly to `lightColor`, making the light source object appear as a solid color.

---

## 6. Build and Run

1.  **Dependencies:** Ensure GLFW, GLAD, GLM, and stb_image.h are correctly set up in your project's include and library paths.
2.  **Compilation:** Compile all `.cpp` source files together.
    *   Example (g++): `g++ main.cpp Shape.cpp Cube.cpp Plane.cpp ... Texture.cpp ShaderClass.cpp Camera.cpp VAO.cpp VBO.cpp EBO.cpp glad.c -o gallery -lglfw -lGL -ldl -pthread` (adjust libraries for your system).
    *   For Visual Studio, add all source files to the project.
3.  **Assets:** Place shader files (`.vert`, `.frag`) and texture image files (`.png`) in the same directory as the executable, or ensure the paths in the code correctly point to them.
4.  **Run:** Execute the compiled program.

---

## 7. Future Improvements

*   **Correct Normal Transformation:** Implement `Normal = mat3(transpose(inverse(model))) * aNormal;` in `default.vert` for accurate lighting under all object transformations.
*   **Advanced Lighting:**
    *   Support multiple light sources (arrays of light structs in shaders).
    *   Implement different light types (directional lights, spotlights).
    *   Add shadow mapping.
*   **Material System:** Create a `Material` class or struct to define properties like diffuse color (if not textured), specular color, shininess, ambient color per object, and pass these to shaders.
*   **Scene Graph:** For more complex scenes, a scene graph structure can help manage object hierarchies and transformations more effectively.
*   **Improved Cylinder/Sphere Geometry:** Refine the geometry generation for smoother results, especially UV mapping and normals for complex cases like cones. Fix any remaining culling issues by perfecting winding orders.
*   **Skybox/Environment:** Add a skybox for a more immersive background.
*   **User Interface:** Use a library like ImGui for real-time tweaking of parameters, camera controls, light properties, etc.
*   **Error Handling:** More robust error checking for OpenGL calls (`glGetError`).
*   **Gamma Correction:** Implement gamma correction for more perceptually accurate colors.
*   **More Shapes:** Add classes for Torus, Teapot, etc.
*   **Model Loading:** Integrate a library like Assimp to load complex 3D models from files (e.g., .obj, .fbx).

This documentation provides a solid overview. Remember that specific implementation details within your VAO/VBO/EBO and other utility classes also contribute to the overall functionality.
