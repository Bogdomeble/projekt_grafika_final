**Project Documentation: OpenGL 3D Scene Renderer**

**Document Status:**
*   Last Updated: 2025-06-01 20:17:16 UTC
*   Updated By: STM32F439
*   Changes in this version: Minor corrections (placeholder text), clarifications, and review for consistency. The core technical descriptions reflect the project state as documented, including known simplifications slated for future improvement.

---

**Table of Contents**

1.  [Overview](#1-overview)
2.  [Core Concepts](#2-core-concepts)
    *   [OpenGL Rendering Pipeline](#opengl-rendering-pipeline)
    *   [Shaders (GLSL)](#shaders-glsl)
    *   [Transformations](#transformations)
    *   [Lighting](#lighting)
    *   [Texturing](#texturing)
3.  [Project Structure](#3-project-structure)
4.  [Class Reference](#4-class-reference)
    *   [main.cpp](#maincpp)
    *   [Shader](#shader-class)
    *   [Texture](#texture-class)
    *   [Camera](#camera-class)
    *   [VAO (Vertex Array Object)](#vao-vertex-array-object-class)
    *   [VBO (Vertex Buffer Object)](#vbo-vertex-buffer-object-class)
    *   [EBO (Element Buffer Object)](#ebo-element-buffer-object-class)
    *   [Shape (Abstract Base Class)](#shape-abstract-base-class)
    *   [Cube (Derived Shape)](#cube-derived-shape)
    *   [Plane (Derived Shape)](#plane-derived-shape)
    *   [Pyramid (Derived Shape)](#pyramid-derived-shape)
    *   [Sphere (Derived Shape)](#sphere-derived-shape)
    *   [Cylinder (Derived Shape)](#cylinder-derived-shape)
5.  [Shader Files](#5-shader-files)
    *   [default.vert](#defaultvert-object-vertex-shader)
    *   [default.frag](#defaultfrag-object-fragment-shader)
    *   [light.vert](#lightvert-light-source-vertex-shader)
    *   [light.frag](#lightfrag-light-source-fragment-shader)
6.  [Build and Run](#6-build-and-run)
7.  [Future Improvements](#7-future-improvements)

---

## 1. Overview

This project is a C++ application that uses OpenGL to render a 3D scene, specifically a simple art gallery. It demonstrates core computer graphics concepts including 3D object representation, transformations, lighting, texturing, and camera control. The codebase is structured using object-oriented principles, with classes representing geometric shapes, shaders, textures, and a camera.

The primary goal is to create a flexible system where new shapes can be easily added and a scene can be constructed by instantiating and positioning these shapes, applying textures, and setting up light sources.

## 2. Core Concepts

### OpenGL Rendering Pipeline

OpenGL is a state machine. We provide it with data (vertices, textures) and instructions (shaders, draw calls), and it processes this through a series of stages (the rendering pipeline) to produce a 2D image on the screen. Key stages include Vertex Shading, Primitive Assembly, Geometry Shading (optional), Rasterization, Fragment Shading, and Tests & Blending.

### Shaders (GLSL)

Shaders are small programs written in GLSL (OpenGL Shading Language) that run on the GPU. They give us direct control over programmable stages of the rendering pipeline.

*   **Vertex Shader:** Processes each vertex individually. Responsible for transforming vertex positions from model space to clip space, and passing data (like texture coordinates, normals) to the fragment shader.
*   **Fragment Shader (Pixel Shader):** Processes each "fragment" (potential pixel) generated by rasterization. Responsible for determining the final color of the pixel, often by performing lighting calculations and texture sampling.

### Transformations

3D objects are defined in their own local "model space". To place them in a "world space", then view them from a "camera space", and finally project them onto a 2D "clip space" (and then "screen space"), we use transformation matrices:

*   **Model Matrix:** Transforms vertices from model space to world space (handles translation, rotation, scaling of an object).
*   **View Matrix:** Transforms vertices from world space to camera/view space (simulates camera position and orientation).
*   **Projection Matrix:** Transforms vertices from camera space to clip space (defines the viewing frustum, e.g., perspective or orthographic projection).
These are often combined: `gl_Position = Projection * View * Model * vec4(vertexPosition, 1.0);`

### Lighting

Simulates how light interacts with surfaces. Common models include:

*   **Ambient Light:** Global, directionless light that illuminates all objects equally, preventing them from being completely black in shadows.
*   **Diffuse Light:** Light that scatters evenly in all directions when it hits a surface. The amount of diffuse light depends on the angle between the surface normal and the light direction.
*   **Specular Light:** Simulates shiny highlights on surfaces. Depends on the light direction, surface normal, and view direction.
*   **Point Light:** A light source that emits light equally in all directions from a single point, with intensity decreasing with distance (attenuation).

### Texturing

Applying 2D images (textures) to the surfaces of 3D objects to add detail and realism. This involves:

*   **Texture Coordinates (UVs):** 2D coordinates (typically ranging from 0 to 1) assigned to each vertex, specifying which part of the texture image maps to that vertex.
*   **Samplers:** Special uniform types in shaders (`sampler2D`) used to access texture data.
*   **Texture Units:** OpenGL provides multiple "slots" (texture units) where textures can be bound. Shaders are told which unit a sampler should use.

## 3. Project Structure

The project is typically organized as follows:

*   **Header Files (.h):** Contain class declarations and function prototypes.
    *   `camera.h`, `EBO.h`, `shaderClass.h`, `Shape.h`, `texture.h`, `VAO.h`, `VBO.h`
    *   Specific shape headers: `Cube.h`, `Plane.h`, `Pyramid.h`, `Sphere.h`, `Cylinder.h`
    *   Potentially an `include.h` to group common includes.
*   **Source Files (.cpp):** Contain class method implementations and the main function.
    *   `main.cpp`
    *   `camera.cpp`, `EBO.cpp`, `shaderClass.cpp`, `Shape.cpp`, `texture.cpp`, `VAO.cpp`, `VBO.cpp`
    *   Specific shape sources: `Cube.cpp`, `Plane.cpp`, `Pyramid.cpp`, `Sphere.cpp`, `Cylinder.cpp`
*   **Shader Files (.vert, .frag):** GLSL code for vertex and fragment shaders.
    *   `default.vert`, `default.frag` (for general objects)
    *   `light.vert`, `light.frag` (for visualizing light sources)
*   **Texture Image Files (.png, .jpg, etc.):** Image files used for texturing.
*   **External Libraries:**
    *   GLFW: For window creation and input handling.
    *   GLAD: OpenGL Loading Library, to access modern OpenGL functions.
    *   GLM: OpenGL Mathematics library, for vector and matrix operations.
    *   stb_image.h: Single-file library for loading images.

## 4. Class Reference

### main.cpp

*   **Purpose:** The main entry point of the application.
*   **Responsibilities:**
    *   **Initialization:** Initializes GLFW, creates a window, and initializes GLAD.
    *   **Global OpenGL State:** Sets up global states like depth testing and face culling.
    *   **Resource Loading:**
        *   Creates and compiles `Shader` objects from shader source files.
        *   Loads `Texture` objects from image files.
    *   **Scene Setup:**
        *   Creates a `Camera` object.
        *   Instantiates various `Shape`-derived objects (e.g., `Plane` for floor/walls, `Cube`, `Pyramid` for artworks/pedestals, `Sphere`, `Cylinder`).
        *   Sets their model matrices for position, rotation, and scale.
        *   Assigns textures to these shapes using `shape->setTexture()`.
        *   Calls `shape->setupMesh()` for each shape to generate its geometry and OpenGL buffers.
        *   Creates light source visualization objects (typically small cubes).
    *   **Render Loop** (`while (!glfwWindowShouldClose(window))`):
        *   Handles per-frame logic: timing, input processing.
        *   Updates camera position/orientation based on input.
        *   Updates light positions or other animated elements.
        *   Clears the screen (color, depth, and stencil buffers).
        *   Sets shader uniforms that are common for a pass (e.g., camera matrix, light properties).
        *   Iterates through scene objects and calls their `draw()` method.
        *   Swaps front and back buffers (`glfwSwapBuffers`).
        *   Polls for events (`glfwPollEvents`).
    *   **Cleanup:** Deletes textures, shaders, and other allocated resources. Terminates GLFW.

### Shader Class

*   **Header:** `shaderClass.h`
*   **Source:** `shaderClass.cpp`
*   **Purpose:** Encapsulates an OpenGL shader program, which consists of a vertex shader and a fragment shader (and optionally others like geometry shader).
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the linked shader program.
*   **Key Methods:**
    *   `Shader(const char* vertexFile, const char* fragmentFile)`: Constructor. Reads shader source code from specified files, compiles the vertex and fragment shaders, links them into a shader program, and stores the program ID. Handles error checking during compilation and linking.
    *   `Activate()`: Calls `glUseProgram(ID)` to make this shader program active for subsequent rendering calls.
    *   `Delete()`: Calls `glDeleteProgram(ID)` to free the GPU resources associated with the shader program.
    *   (Helper function `get_file_contents` is typically used internally to read shader files.)

### Texture Class

*   **Header:** `texture.h`
*   **Source:** `texture.cpp`
*   **Purpose:** Manages an OpenGL texture object.
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the texture object.
    *   `type`: `GLenum` specifying the texture type (e.g., `GL_TEXTURE_2D`).
*   **Key Methods:**
    *   `Texture(const char* image_path, GLenum tex_type, GLenum active_slot, GLenum format_hint, GLenum pixel_type_hint)`: Constructor.
        *   Loads an image file from `image_path` using `stb_image.h`.
        *   Checks for loading errors. If an error occurs, `ID` is typically set to 0.
        *   Determines the data format (e.g., `GL_RGB`, `GL_RGBA`) based on the number of channels in the loaded image.
        *   Generates an OpenGL texture ID using `glGenTextures`.
        *   Activates the specified `active_slot` (texture unit) using `glActiveTexture`.
        *   Binds the new texture object using `glBindTexture`.
        *   Sets pixel storage parameters (especially `glPixelStorei(GL_UNPACK_ALIGNMENT, 1)` for tightly packed data from `stb_image`).
        *   Sets texture parameters (filtering: `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`; wrapping: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`).
        *   Uploads the image data to the GPU using `glTexImage2D`. It uses an appropriate `internalFormat` (e.g., `GL_RGBA8`) and the `format` (e.g., `GL_RGB`, `GL_RGBA`) determined from the loaded image's channels.
        *   Generates mipmaps using `glGenerateMipmap`.
        *   Frees the CPU-side image data loaded by `stb_image` using `stbi_image_free`.
    *   `texUnit(Shader& shader, const char* uniform_name, GLuint unit_index)`: Tells a specified shader's sampler uniform (`uniform_name`) to use the texture bound to the texture unit `unit_index`. It activates the shader and calls `glUniform1i`.
    *   `Bind()`: Calls `glBindTexture(type, ID)` to bind this texture. Assumes `glActiveTexture` was called beforehand if a specific unit is intended.
    *   `Unbind()`: Calls `glBindTexture(type, 0)` to unbind the texture of this type from the currently active texture unit.
    *   `Delete()`: Calls `glDeleteTextures(1, &ID)` to free the GPU resources and sets `ID` to 0.

### Camera Class

*   **Header:** `camera.h`
*   **Source:** `camera.cpp`
*   **Purpose:** Manages the view and projection transformations, simulating a camera in the 3D scene. Handles user input for camera movement and orientation.
*   **Key Members:**
    *   `Position`: `glm::vec3` for the camera's world space position.
    *   `Orientation`: `glm::vec3` a unit vector indicating the direction the camera is looking (forward vector).
    *   `Up`: `glm::vec3` a unit vector indicating the up direction for the camera (world up, typically (0,1,0)).
    *   `cameraMatrix`: `glm::mat4` that stores the combined View * Projection matrix.
    *   `width`, `height`: Dimensions of the viewport, used for aspect ratio in projection.
    *   `speed`, `sensitivity`: Control camera movement speed and mouse look sensitivity.
    *   `firstClick`: `bool` to handle initial mouse capture smoothly.
    *   `deltaTime`: Time difference between frames, used for frame-rate independent movement.
*   **Key Methods:**
    *   `Camera(int width, int height, glm::vec3 position)`: Constructor, initializes camera properties.
    *   `updateMatrix(float FOVdeg, float nearPlane, float farPlane)`: Calculates the view matrix using `glm::lookAt(Position, Position + Orientation, Up)` and the perspective projection matrix using `glm::perspective()`. Combines them into `cameraMatrix = projection * view`.
    *   `Matrix(Shader& shader, const char* uniform)`: Activates the given shader and sends the `cameraMatrix` (View-Projection matrix) to the shader uniform specified by `uniform`.
    *   `Inputs(GLFWwindow* window)`: Handles keyboard input (W,A,S,D, Space, Ctrl) for camera movement (FPS-style) and mouse input for camera orientation (looking around). Implements mouse capture and cursor hiding when the left mouse button is pressed.

### VAO (Vertex Array Object) Class

*   **Header:** `VAO.h`
*   **Source:** `VAO.cpp` (if methods are not inline)
*   **Purpose:** Stores all the state needed to supply vertex data. It encapsulates vertex attribute configurations and bindings to VBOs and an EBO. Using a VAO allows you to set up vertex attribute pointers once and then just bind the VAO to draw an object.
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the Vertex Array Object.
*   **Key Methods:**
    *   `VAO()`: Constructor, calls `glGenVertexArrays(1, &ID)` to generate a VAO ID.
    *   `LinkAttrib(VBO& vbo, GLuint layout, GLuint numComponents, GLenum type, GLsizei stride, void* offset)`:
        *   Binds the associated `vbo`.
        *   Calls `glVertexAttribPointer` to specify how OpenGL should interpret the vertex data in the VBO for a given attribute `layout` (e.g., position, color, texcoord).
            *   `layout`: The location of the vertex attribute in the vertex shader.
            *   `numComponents`: Number of components per attribute (e.g., 3 for `vec3`).
            *   `type`: Data type of components (e.g., `GL_FLOAT`).
            *   `stride`: Byte offset between consecutive vertex attributes.
            *   `offset`: Byte offset of the first component of the first attribute.
        *   Calls `glEnableVertexAttribArray(layout)` to enable this vertex attribute.
        *   Unbinds the `vbo` (optional, good practice).
    *   `Bind()`: Calls `glBindVertexArray(ID)`.
    *   `Unbind()`: Calls `glBindVertexArray(0)`.
    *   `Delete()`: Calls `glDeleteVertexArrays(1, &ID)`.

### VBO (Vertex Buffer Object) Class

*   **Header:** `VBO.h`
*   **Source:** `VBO.cpp` (if methods are not inline)
*   **Purpose:** Manages an OpenGL buffer object used to store vertex attribute data (like positions, colors, texture coordinates, normals) on the GPU.
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the Vertex Buffer Object.
*   **Key Methods:**
    *   `VBO(GLfloat* vertices, GLsizeiptr size)`: Constructor.
        *   Calls `glGenBuffers(1, &ID)` to generate a VBO ID.
        *   Calls `glBindBuffer(GL_ARRAY_BUFFER, ID)` to bind the VBO.
        *   Calls `glBufferData(GL_ARRAY_BUFFER, size, vertices, GL_STATIC_DRAW)` to allocate memory on the GPU and upload the vertex data. `GL_STATIC_DRAW` indicates the data will be set once and used many times.
    *   `Bind()`: Calls `glBindBuffer(GL_ARRAY_BUFFER, ID)`.
    *   `Unbind()`: Calls `glBindBuffer(GL_ARRAY_BUFFER, 0)`.
    *   `Delete()`: Calls `glDeleteBuffers(1, &ID)`.

### EBO (Element Buffer Object) Class

*   **Header:** `EBO.h`
*   **Source:** `EBO.cpp` (if methods are not inline)
*   **Purpose:** Manages an OpenGL buffer object used to store vertex indices. This allows for "indexed drawing" (`glDrawElements`), where you can reuse vertices instead of duplicating them, saving memory and potentially improving performance.
*   **Key Members:**
    *   `ID`: `GLuint` storing the OpenGL ID of the Element Buffer Object.
*   **Key Methods:**
    *   `EBO(GLuint* indices, GLsizeiptr size)`: Constructor.
        *   Calls `glGenBuffers(1, &ID)` to generate an EBO ID.
        *   Calls `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ID)` to bind the EBO.
        *   Calls `glBufferData(GL_ELEMENT_ARRAY_BUFFER, size, indices, GL_STATIC_DRAW)` to upload the index data.
    *   `Bind()`: Calls `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ID)`.
    *   `Unbind()`: Calls `glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)`.
    *   `Delete()`: Calls `glDeleteBuffers(1, &ID)`.

### Shape (Abstract Base Class)

*   **Header:** `Shape.h`
*   **Source:** `Shape.cpp`
*   **Purpose:** Serves as an abstract base class for all renderable geometric shapes in the scene. It handles common functionality like managing VAO/VBO/EBO, model matrix transformations, texture assignment, and providing a common drawing interface.
*   **Key Members (Protected):**
    *   `vertices_data`: `std::vector<GLfloat>` to store the interleaved vertex attribute data (position, color, texture coordinates, normal).
    *   `indices_data`: `std::vector<GLuint>` to store the indices for indexed drawing.
    *   `vao`: A `VAO` object owned by the shape.
    *   `vbo_ptr`, `ebo_ptr`: `std::unique_ptr` to `VBO` and `EBO` objects, managing their lifetime.
    *   `meshInitialized`: `bool` flag indicating if the OpenGL buffers (VAO/VBO/EBO) have been set up.
    *   `shapeTexture`: `Texture*` pointer to the texture assigned to this shape.
*   **Key Members (Public):**
    *   `modelMatrix`: `glm::mat4` representing the object's transformation (translation, rotation, scale) in world space. Initialized to identity.
    *   `stride`: `size_t` defining the byte offset between consecutive full vertex attribute sets.
*   **Key Methods:**
    *   `Shape()`: Constructor, initializes `modelMatrix` and default member values.
    *   `virtual ~Shape()`: Virtual destructor, calls `cleanup()` to ensure OpenGL resources are released when a derived shape object is deleted, especially through a base class pointer.
    *   `addVertex(...)`: Protected helper method for derived classes to easily add a full set of vertex attributes to `vertices_data`.
    *   `virtual void generateGeometry() = 0`: Pure virtual method. Derived classes must implement this to populate `vertices_data` and `indices_data` with their specific geometry.
    *   `virtual void setupMesh()`:
        *   If the mesh is not already initialized (`vertices_data` or `indices_data` are empty), it calls the derived class's `generateGeometry()` method.
        *   Creates the VBO and EBO using the data from `vertices_data` and `indices_data`.
        *   Binds the VAO.
        *   Calls `vao.LinkAttrib()` multiple times to configure how the vertex attributes (position, color, texture coordinates, normal) are laid out in the VBO.
        *   Unbinds the VAO.
        *   Sets `meshInitialized` to `true`.
    *   `setTexture(Texture* tex)`: Assigns a `Texture` object to this shape's `shapeTexture` member.
    *   `virtual void draw(Shader& shader)`:
        *   Checks if `meshInitialized`. If not, (optionally attempts `setupMesh()` or) prints an error.
        *   Activates the provided `shader`.
        *   Sends the shape's `modelMatrix` to the shader's "model" uniform.
        *   If `this->shapeTexture` is valid (not null and its `ID` is not 0):
            *   Activates `GL_TEXTURE0` (or the appropriate texture unit).
            *   Binds `this->shapeTexture` using `this->shapeTexture->Bind()`.
        *   Binds the shape's VAO.
        *   Calls `glDrawElements(GL_TRIANGLES, getIndexCount(), GL_UNSIGNED_INT, 0)` to draw the object using its EBO.
        *   Unbinds the VAO.
    *   `cleanup()`: Deletes the VBO, EBO, and VAO OpenGL resources using their respective `Delete()` methods. Resets smart pointers and `meshInitialized` flag.

### Cube (Derived Shape)

*   **Header:** `Cube.h`
*   **Source:** `Cube.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a 3D cube.
*   **Key Members (Private):**
    *   `width`, `height`, `depth`: Dimensions of the cube.
    *   `faceColor`: A `glm::vec3` for the base color of the cube's faces (used when generating vertex data).
*   **Key Methods:**
    *   `Cube(float w, float h, float d, const glm::vec3& color)`: Constructor, initializes dimensions and color.
    *   `void generateGeometry() override`: Implements the geometry generation for a cube.
        *   Defines 8 unique vertex positions for the corners of the cube.
        *   Since each face needs its own normals (and potentially distinct texture coordinates per face for standard UV unwrapping), it defines 24 vertices (4 vertices per face * 6 faces).
        *   For each face:
            *   Adds 4 vertices to `vertices_data` with appropriate positions, the `faceColor`, standard texture coordinates (e.g., (0,0), (1,0), (1,1), (0,1)), and the correct face normal.
            *   Adds 6 indices (for 2 triangles) to `indices_data` to form the face.

### Plane (Derived Shape)

*   **Header:** `Plane.h`
*   **Source:** `Plane.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a flat 2D plane in 3D space, typically used for floors, walls, or simple quads like paintings.
*   **Key Members (Private):**
    *   `p_width`, `p_length`: Dimensions of the plane.
    *   `p_color`: Base color.
    *   `p_texScale`: `glm::vec2` to scale texture coordinates (e.g., for tiling).
    *   `p_yOffset`: Y-coordinate offset for the plane (defaults to 0, creating a plane in the XZ plane).
*   **Key Methods:**
    *   `Plane(float width, float length, const glm::vec3& color, const glm::vec2& texScale, float yOffset)`: Constructor.
    *   `void generateGeometry() override`:
        *   Calculates 4 vertex positions for the corners of the plane based on `p_width`, `p_length`, and `p_yOffset`.
        *   Defines a single normal vector (typically (0,1,0) if the plane is horizontal and facing up).
        *   Calculates texture coordinates, applying `p_texScale`.
        *   Adds 4 vertices to `vertices_data`.
        *   Adds 6 indices (for 2 triangles) to `indices_data` to form the plane.

### Pyramid (Derived Shape)

*   **Header:** `Pyramid.h`
*   **Source:** `Pyramid.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a 4-sided pyramid with a square base.
*   **Key Members (Private):**
    *   `baseColor`, `peakColor`: Colors used for the base and the peak vertex/sides when generating geometry.
*   **Key Methods:**
    *   `Pyramid(const glm::vec3& bColor, const glm::vec3& pColor)`: Constructor.
    *   `void generateGeometry() override`:
        *   Defines vertices for the square base (4 vertices).
        *   Defines a peak vertex.
        *   Similar to the cube, if different faces need different normals (which they do for a pyramid), vertices are duplicated.
        *   Adds vertices for the bottom face (typically 2 triangles, 4 vertices with bottom-facing normal).
        *   Adds vertices for each of the 4 triangular side faces (3 vertices per side, each with its specific normal).
        *   Populates `indices_data` accordingly.

### Sphere (Derived Shape)

*   **Header:** `Sphere.h`
*   **Source:** `Sphere.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a sphere.
*   **Key Members (Private):**
    *   `radius`: Radius of the sphere.
    *   `sectorCount`: Number of longitudinal segments (like orange slices).
    *   `stackCount`: Number of latitudinal segments (like horizontal rings).
    *   `sphereColor`: Base color.
*   **Key Methods:**
    *   `Sphere(float r, unsigned int sectors, unsigned int stacks, const glm::vec3& color)`: Constructor.
    *   `void generateGeometry() override`:
        *   Generates vertices by iterating through stack and sector angles using spherical coordinates.
        *   For each vertex, calculates:
            *   Position (x,y,z).
            *   Normal (for a sphere centered at origin, normal is `normalize(position)`).
            *   Texture coordinates (typically mapping longitude to u and latitude to v).
        *   Adds vertices to `vertices_data`.
        *   Generates indices to form triangular strips connecting the stacks and sectors. Handles poles carefully.

### Cylinder (Derived Shape)

*   **Header:** `Cylinder.h`
*   **Source:** `Cylinder.cpp`
*   **Inherits from:** `Shape`
*   **Purpose:** Represents a cylinder (or a cone/frustum if top and base radii differ).
*   **Key Members (Private):**
    *   `baseRadius`, `topRadius`: Radii of the bottom and top circular caps.
    *   `height`: Height of the cylinder.
    *   `sectorCount`: Number of segments around the circular caps.
    *   `stackCount`: Number of segments along the height for the side walls.
    *   `smoothShading`: Boolean to indicate if side wall normals should be smooth (averaged) or flat (per-face, requiring more vertices usually).
    *   `cylinderColor`: Base color.
*   **Key Methods:**
    *   `Cylinder(float br, float tr, float h, unsigned int sectors, unsigned int stacks, bool smooth, const glm::vec3& color)`: Constructor.
    *   `void generateGeometry() override`:
        *   **Side Walls:**
            *   Iterates through `stackCount` and `sectorCount`.
            *   For each point on the side, calculates vertex position by interpolating radius from `baseRadius` to `topRadius` along the height.
            *   Calculates normals: For smooth shading on a cylinder, normal points radially outward from the Y-axis. For a cone, it's more complex.
            *   Calculates texture coordinates (typically u maps around the circumference, v maps along the height).
            *   Adds vertices to `vertices_data`.
            *   Generates indices for the triangular strips forming the side walls.
        *   **Caps (Top and Bottom):**
            *   If `baseRadius > 0`, generates a bottom circular cap (a triangle fan originating from a center vertex). Vertices have normals pointing downwards ((0,-1,0)).
            *   If `topRadius > 0`, generates a top circular cap (triangle fan). Vertices have normals pointing upwards ((0,1,0)).
            *   Calculates planar texture coordinates for the caps.
            *   Adds vertices and indices for the caps.
        *   Winding order for cylinder faces is critical for correct culling and may require careful debugging.

## 5. Shader Files

### default.vert (Object Vertex Shader)

*   **Inputs (in):**
    *   `layout (location = 0) in vec3 aPos;` : Per-vertex position (in model space).
    *   `layout (location = 1) in vec3 aColor;`: Per-vertex color.
    *   `layout (location = 2) in vec2 aTex;` : Per-vertex texture coordinates.
    *   `layout (location = 3) in vec3 aNormal;`: Per-vertex normal (in model space).
*   **Outputs (out):**
    *   `out vec3 crntPos;`: Fragment's position in world space (interpolated).
    *   `out vec3 Normal;` : Fragment's normal (interpolated, should be transformed to world space).
    *   `out vec2 texCoord;`: Texture coordinates (interpolated).
    *   `out vec3 color;` : Vertex color (interpolated).
*   **Uniforms (uniform):**
    *   `uniform mat4 model;` : Model matrix for the current object.
    *   `uniform mat4 camMatrix;`: Combined View * Projection matrix.
*   **Functionality:**
    *   Transforms `aPos` to world space using `model` matrix, outputting to `crntPos`.
    *   Transforms `crntPos` to clip space using `camMatrix`, setting `gl_Position`.
    *   Passes `aTex` to `texCoord`.
    *   Passes `aColor` to `color`.
    *   **Important Note on Normals:** For correct lighting under all transformations (especially non-uniform scaling or rotations), `aNormal` should be transformed to world space using the normal matrix (typically `mat3(transpose(inverse(model)))`) before being output to `Normal`. The current shader, as described, simplifies this to `Normal = aNormal;` (or `Normal = mat3(model) * aNormal;` if only uniform scaling/rotation), which is only correct if the model matrix contains no non-uniform scales or specific types of rotations. This simplification is common in introductory examples but has limitations in general scenarios.

### default.frag (Object Fragment Shader)

*   **Inputs (in):** (Received from vertex shader, interpolated)
    *   `in vec3 crntPos;` : Fragment position in world space.
    *   `in vec3 Normal;` : Fragment normal in world space (see note in `default.vert`).
    *   `in vec2 texCoord;` : Texture coordinates.
    *   `in vec3 color;` : Interpolated vertex color (currently documented as unused in the final lighting calculation shown below, which primarily uses texture color).
*   **Uniforms (uniform):**
    *   `uniform sampler2D tex0;`: Sampler for the object's diffuse texture.
    *   `uniform vec4 lightColor;`: Color of the single point light source.
    *   `uniform vec3 lightPos;` : Position of the single point light source in world space.
    *   `uniform vec3 camPos;` : Position of the camera in world space.
*   **Functionality (Single Point Light - Blinn-Phong like):**
    *   **Ambient:** Calculates a small ambient light component.
    *   **Diffuse:**
        *   Normalizes the incoming `Normal`.
        *   Calculates `lightDirection` from fragment to light.
        *   Calculates diffuse intensity using `max(dot(normal, lightDirection), 0.0)`.
    *   **Specular:**
        *   Calculates `viewDirection` from fragment to camera.
        *   Calculates `reflectionDirection` of light off the surface (or uses `halfwayDir` for Blinn-Phong).
        *   Calculates specular power using `pow(max(dot(viewDirection, reflectionDirection_or_halfwayDir), 0.0), shininessFactor)`. (Described with `shininessFactor = 8`).
    *   **Final Color:** Combines ambient, diffuse, and specular components, then modulates this by the `lightColor` and the color sampled from `tex0` using `texCoord`. `FragColor` is the output.

### light.vert (Light Source Vertex Shader)

*   **Inputs (in):**
    *   `layout (location = 0) in vec3 aPos;`: Vertex position of the light object (e.g., a cube).
*   **Uniforms (uniform):**
    *   `uniform mat4 model;` : Model matrix for the light object (its position/scale).
    *   `uniform mat4 camMatrix;`: Combined View * Projection matrix.
*   **Functionality:** Transforms the light object's vertices to clip space: `gl_Position = camMatrix * model * vec4(aPos, 1.0);`.

### light.frag (Light Source Fragment Shader)

*   **Uniforms (uniform):**
    *   `uniform vec4 lightColor;`: The color the light source object should appear as.
*   **Functionality:** Sets the output fragment color `FragColor` directly to `lightColor`, making the light source object appear as a solid color.

## 6. Build and Run

*   **Dependencies:** Ensure GLFW, GLAD, GLM, and `stb_image.h` are correctly set up in your project's include and library paths.
*   **Compilation:** Compile all `.cpp` source files together.
    *   Example (g++): `g++ main.cpp Shape.cpp Cube.cpp Plane.cpp ... Texture.cpp ShaderClass.cpp Camera.cpp VAO.cpp VBO.cpp EBO.cpp glad.c -o gallery -lglfw -lGL -ldl -pthread` (adjust libraries for your system).
    *   For Visual Studio, add all source files to the project.
*   **Assets:** Place shader files (`.vert`, `.frag`) and texture image files (`.png`) in the same directory as the executable, or ensure the paths in the code correctly point to them.
*   **Run:** Execute the compiled program.

## 7. Future Improvements

*   **Correct Normal Transformation:** Implement `Normal = mat3(transpose(inverse(model))) * aNormal;` in `default.vert` for accurate lighting under all object transformations.
*   **Advanced Lighting:**
    *   Support multiple light sources (arrays of light structs in shaders).
    *   Implement different light types (directional lights, spotlights).
    *   Add shadow mapping.
*   **Material System:** Create a `Material` class or struct to define properties like diffuse color (if not textured), specular color, shininess, ambient color per object, and pass these to shaders. This would also clarify the use of per-vertex color vs. texture color.
*   **Scene Graph:** For more complex scenes, a scene graph structure can help manage object hierarchies and transformations more effectively.
*   **Improved Cylinder/Sphere Geometry:** Refine the geometry generation for smoother results, especially UV mapping and normals for complex cases like cones. Fix any remaining culling issues by perfecting winding orders.
*   **Skybox/Environment:** Add a skybox for a more immersive background.
*   **User Interface:** Use a library like ImGui for real-time tweaking of parameters, camera controls, light properties, etc.
*   **Error Handling:** More robust error checking for OpenGL calls (`glGetError`).
*   **Gamma Correction:** Implement gamma correction for more perceptually accurate colors.
*   **More Shapes:** Add classes for Torus, Teapot, etc.
*   **Model Loading:** Integrate a library like Assimp to load complex 3D models from files (e.g., `.obj`, `.fbx`).
